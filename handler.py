import hashlib
import json
import logging
import os
import re
import sqlite3

from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton, BotCommand
from telegram.ext import Updater, MessageHandler, CommandHandler, Filters, CallbackContext, CallbackQueryHandler

DB_NAME = './db/tobedo.sqlite3'

CHECK_CHAR = '✅'
UNCHECK_CHAR = '⬜'

def gen_db():
    # table: Replies
    # message_and_chat_id, reply_id, created_at
    # unique index on message_id
    with sqlite3.connect(DB_NAME) as db:
        db.execute('''
            CREATE TABLE IF NOT EXISTS Replies (
                message_and_chat_id VARCHAR(255) NOT NULL,
                reply_and_chat_id VARCHAR(255) NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                state TEXT,
                PRIMARY KEY (message_and_chat_id),
                UNIQUE (reply_and_chat_id)
            )
        ''')

        # store mode for each chat
        db.execute('''
            CREATE TABLE IF NOT EXISTS ChatModes (
                chat_id VARCHAR(255) NOT NULL,
                mode VARCHAR(255) NOT NULL,
                PRIMARY KEY (chat_id)
            )
        ''')

        db.commit()

def set_chat_mode(update, context, mode):
    if not check_admin(update, context):
        return
    chat_id = update.message.chat_id
    print('setting chat mode', chat_id, mode)
    with sqlite3.connect(DB_NAME) as db:
        db.execute('''
            INSERT OR REPLACE INTO ChatModes (chat_id, mode) VALUES (?, ?)
        ''', (chat_id, mode))

        db.commit()
    # reply to user
    update.message.reply_text(f'Now checklist will appear in reply only to messages starting with "todo" or "td" or "c "' if mode == 'todo' else \
                               'Now checklist will appear in reply to any message (expect starting with . or !)')

def get_chat_mode(chat_id):
    with sqlite3.connect(DB_NAME) as db:
        cursor = db.execute('''
            SELECT mode FROM ChatModes WHERE chat_id = ?
        ''', (chat_id,))

        row = cursor.fetchone()
        if not row:
            return None
        return row[0]

def cleanup_old_replies():
    # delete posts older then 1 year
    with sqlite3.connect(DB_NAME) as db:
        db.execute('''
            DELETE FROM Replies WHERE created_at < datetime('now', '-1 year')
        ''')

        db.commit()

def get_reply_by_message_id(message_id, chat_id) -> tuple:
    with sqlite3.connect(DB_NAME) as db:
        cursor = db.execute('''
            SELECT reply_and_chat_id, state FROM Replies WHERE message_and_chat_id = ?
        ''', (f"{chat_id}_{message_id}",))

        row = cursor.fetchone()
        if not row:
            return None, None
        return row[0], json.loads(row[1]) if row[1] else {}


def get_all_todos(chat_id):
    """Get all todo items for a specific chat"""
    with sqlite3.connect(DB_NAME) as db:
        cursor = db.execute('''
            SELECT message_and_chat_id, reply_and_chat_id, state, created_at
            FROM Replies
            WHERE message_and_chat_id LIKE ?
            ORDER BY created_at DESC
        ''', (f"{chat_id}_%",))

        todos = []
        for row in cursor.fetchall():
            message_id = row[0].split('_')[1]
            state = json.loads(row[2]) if row[2] else {}
            created_at = row[3]

            # Add each todo item with its completion status
            for item_text, is_completed in state.items():
                todos.append({
                    'message_id': message_id,
                    'text': item_text,
                    'completed': is_completed,
                    'created_at': created_at
                })

        return todos


def insert_reply(message_id, reply_id, chat_id):
    with sqlite3.connect(DB_NAME) as db:
        db.execute(
            '''
            INSERT INTO Replies (message_and_chat_id, reply_and_chat_id, state) VALUES (?, ?, ?)
            ''',
            (f"{chat_id}_{message_id}", f"{chat_id}_{reply_id}", "{}")
        )

        db.commit()

def update_reply(reply_id, chat_id, state: dict):
    with sqlite3.connect(DB_NAME) as db:
        db.execute('''
            UPDATE Replies SET state = ? WHERE reply_and_chat_id = ?
        ''',
        (json.dumps(state), f"{chat_id}_{reply_id}"))

        db.commit()



logger = logging.getLogger(__name__)

TOKEN = os.environ.get('TG_TOKEN')
if not TOKEN:
    print('TG_TOKEN not specified in env, please set TG_TOKEN with your bot token generated by @BotFather')
    exit(1)

def button_click(update, context):
    query = update.callback_query

    if query.data.startswith('toggle__'):
        index = query.data.replace('toggle__', '')

        if not query.message.reply_markup:
            print(f'no reply_markup for message_id {query.message.message_id} and chat_id {query.message.chat_id}')
            return

        for i, btn in enumerate(query.message.reply_markup.inline_keyboard):
            checked = btn[0].text.startswith(CHECK_CHAR)
            btn_text = btn[0].text.replace(f'{UNCHECK_CHAR} ', '').replace(f'{CHECK_CHAR} ', '')
            if i == int(index):
                print('found a btn', btn_text)
                new_text = f'{CHECK_CHAR} {btn_text}' if not checked else f'{UNCHECK_CHAR} {btn_text}'
                btn[0].text = new_text
                break

        state = {}
        for btn in query.message.reply_markup.inline_keyboard:
            checked = btn[0].text.startswith(CHECK_CHAR)
            btn_text = btn[0].text.replace(f'{UNCHECK_CHAR} ', '').replace(f'{CHECK_CHAR} ', '')
            state[btn_text] = checked

        print('setting state', state)
        reply_id = query.message.message_id
        update_reply(reply_id, query.message.chat_id, state)


        context.bot.edit_message_text(
            chat_id=query.message.chat_id,
            message_id=query.message.message_id,
            text=f'Click to toggle',
            reply_markup=query.message.reply_markup
        )



def md5hash(text):
    return hashlib.md5(text.encode('utf-8')).hexdigest()


TODO_MODE_REGEX = re.compile(r'^(todo|tobedo|td|tbd|tobedone|checklist|check |cl |c )\s?', re.IGNORECASE)


def echo(update: Update, context: CallbackContext) -> None:
    """
    This function would be added to the dispatcher as a handler for messages coming from the Bot API
    """

    msg = None
    update_object = None

    if update.channel_post:
        msg = update.channel_post.text
        update_object = update.channel_post
    elif update.message:
        msg = update.message.text
        update_object = update.message
    elif update.edited_message:
        msg = update.edited_message.text
        update_object = update.edited_message

    elif update.edited_channel_post:
        msg = update.edited_channel_post.text
        update_object = update.edited_channel_post

    if not msg:
        print('Unrecognized update')
        return

    is_update = update.edited_message or update.edited_channel_post
    previous_state = {}
    if is_update:
        message_id = update_object.message_id
        reply_id_with_message_id, previous_state = get_reply_by_message_id(message_id, update_object.chat_id)
        if not reply_id_with_message_id:
            print(f'reply_id for message_id {message_id} and chat_id {update_object.chat_id} not found')
            return

    # Skip processing commands in the echo handler
    if msg.startswith('/'):
        return

    mode = get_chat_mode(update_object.chat_id)

    if mode == None or mode == 'all':
        if msg.startswith('!') or msg.startswith('.'):
            return
    else:
        if re.match(TODO_MODE_REGEX, msg) == None:
            return
        msg = re.sub(TODO_MODE_REGEX, '', msg)

    lines = msg.split('\n')
    keyboard = []

    index = 0
    for line in lines:
        line_strip = line.strip()

        if line_strip == '':
            continue


        print('previous_state', previous_state)

        keyboard.append([InlineKeyboardButton(
            f"{CHECK_CHAR if previous_state.get(line_strip, False) else UNCHECK_CHAR} {line_strip}",
            callback_data=f"toggle__{index}"
        )])
        index += 1

    reply_markup = InlineKeyboardMarkup(keyboard)

    if not is_update:
        # add new reply
        reply = update_object.reply_text('Click to toggle', reply_markup=reply_markup)
        reply_id = reply.message_id
        message_id = update_object.message_id
        chat_id = update_object.chat_id
        insert_reply(message_id, reply_id, chat_id)

    else:

        # find previous reply to same message and edit it
        # this is a workaround for editing messages in channels
        #
        reply_id = reply_id_with_message_id.split('_')[1]
        context.bot.edit_message_reply_markup(
            chat_id=update_object.chat_id,
            message_id=reply_id,
            reply_markup=reply_markup
        )

def check_admin(update, context):
    now_in_channel = update.message.chat.type == 'channel'
    now_in_group = update.message.chat.type == 'group'
    ia_am_admin = update.message.chat.get_member(context.bot.id).status in ['administrator', 'creator']

    if now_in_channel or now_in_group and not ia_am_admin:
        update.message.reply_text(f'Please promote me to admin in {update.message.chat.type} settings to enable me to generate checklists in replies. I need it because you added me to a {update.message.chat.type}, also you can use me in direct chat without promoting me')
        return False
    return True

# Helper function for testing
def update_message_reply_text(message, parse_mode=None):
    pass

def format_todo_list(todos, filter_completed=None):
    """Format todo items into a readable message"""
    # Filter todos if requested
    if filter_completed is not None:
        todos = [todo for todo in todos if todo['completed'] == filter_completed]

    if not todos:
        return "No todo items found" if filter_completed is None else \
               "No completed todo items found" if filter_completed else \
               "No pending todo items found"

    # Group todos by message_id to show them in their original lists
    todos_by_message = {}
    for todo in todos:
        if todo['message_id'] not in todos_by_message:
            todos_by_message[todo['message_id']] = []
        todos_by_message[todo['message_id']].append(todo)

    # Format the response
    response = "📋 *Your Todo Lists:*\n\n"

    for message_id, items in todos_by_message.items():
        response += f"*List #{message_id}:*\n"
        for item in items:
            status = CHECK_CHAR if item['completed'] else UNCHECK_CHAR
            response += f"{status} {item['text']}\n"
        response += "\n"

    return response

def show_todos(update, context, filter_completed=None):
    """Show all todo items, with optional filtering by completion status"""
    chat_id = update.message.chat_id
    todos = get_all_todos(chat_id)

    # Format the message
    response = format_todo_list(todos, filter_completed)

    # Send the response
    update.message.reply_text(response, parse_mode='Markdown')

    # For testing purposes
    update_message_reply_text(response, parse_mode='Markdown')

def show_all_todos(update, context):
    """Show all todo items regardless of completion status"""
    show_todos(update, context)

def show_completed_todos(update, context):
    """Show only completed todo items"""
    show_todos(update, context, filter_completed=True)

def show_pending_todos(update, context):
    """Show only pending (incomplete) todo items"""
    show_todos(update, context, filter_completed=False)

def startBotPrompt(update, context):
    if check_admin(update, context):
        update.message.reply_text("""Hello! I am your checklist bot. I will reply to your messages with a checklist. You can click on each item to toggle it.
You can set the mode to "todo" with /only_todo command to make me reply only to messages starting with "todo" or "td" or "c ".

Commands:
/todos - Show all your todo items
/pending - Show only incomplete todo items
/completed - Show only completed todo items""")

def main() -> None:
    gen_db()
    cleanup_old_replies()
    updater = Updater(TOKEN)

    # Get the dispatcher to register handlers
    # Then, we register each handler and the conditions the update must meet to trigger it
    dispatcher = updater.dispatcher

    dispatcher.add_handler(CallbackQueryHandler(button_click))


    # Echo any message that is not a command
    dispatcher.add_handler(MessageHandler(~Filters.command, echo))

    # add command /setmode
    # normal, todo, checklist
    dispatcher.add_handler(CommandHandler('only_todo', lambda up, con: set_chat_mode(up, con, 'todo')))

    dispatcher.add_handler(CommandHandler('all', lambda up, con: set_chat_mode(up, con, 'all')))

    dispatcher.add_handler(CommandHandler('start', startBotPrompt))

    # Add new command handlers for todo lists
    dispatcher.add_handler(CommandHandler('todos', show_all_todos))
    dispatcher.add_handler(CommandHandler('pending', show_pending_todos))
    dispatcher.add_handler(CommandHandler('completed', show_completed_todos))

    dispatcher.bot.set_my_commands([
        BotCommand("only_todo", "Set mode to 'todo' messages"),
        BotCommand("all", "Set mode to any messages"),
        BotCommand("start", "Start the bot"),
        BotCommand("todos", "Show all your todo items"),
        BotCommand("pending", "Show only incomplete todo items"),
        BotCommand("completed", "Show only completed todo items")
    ])

    # Start the Bot
    updater.start_polling()

    # Run the bot until you press Ctrl-C
    updater.idle()


if __name__ == '__main__':
    main()
